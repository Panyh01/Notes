# [HTML](./index.md) | 03 canvas标签<!-- omit in toc -->

🌸Author [**Echo Pan**](https://github.com/echopan)

- [简介](#简介)
- [应用领域](#应用领域)
- [格式](#格式)
- [渲染上下文（The rendring context）](#渲染上下文the-rendring-context)
- [绘制模板](#绘制模板)
- [用法](#用法)
  - [绘制矩形](#绘制矩形)
  - [绘制路径](#绘制路径)
    - [beginPath()](#beginpath)
    - [closePath()](#closepath)
    - [`stroke()`](#stroke)
    - [`fill()`](#fill)
    - [`moveTo(x,y)`](#movetoxy)
    - [`lineTo(x,y)`](#linetoxy)
  - [绘制三角形](#绘制三角形)
  - [圆弧](#圆弧)

***

## ✨Echo有话说<!-- omit in toc -->

[_Canvas教程_](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial)

备忘：`proto`

## 简介

`canvas`是`HTML5`提供的用于展示绘图效果的标签。

`canvas`是一个矩形画布，可以用`JS`绘图，它本身没有画图功能。

## 应用领域

- **游戏**
- **数据可视化**  
  包括百度的`Echarts`、`d3.js`、`three.js`、`higncharts`
- **banner 广告**（横幅广告）
- **模拟器，图形编辑器**

## 格式

`canvas`默认大小为 300px * 150px，可以自定义大小：

```html
<canvas width="600" height="400"></canvas>
```

注意，`canvas`可以用CSS来定义大小，区别是html中设置的是画布，而css中设置的是框架，绘图时图片会伸缩来适应该框架大小。而且当css尺寸比例和画布不一样时，图像就会扭曲拉伸。

## 渲染上下文（The rendring context）

`<canvas>`起初是空白的，它公开了一个或多个渲染上下文用来绘制和处理展示的内容，我们的教学基于2D渲染上下文，其他当然还有`WebGL`使用了基于`OpenGL ES`的3D上下文。

脚本要先找到上下文才能绘制，`canvas`提供一个`getContext()`方法，用来获取渲染上下文和绘图功能。`getContext()`可以接受一个参数，即上下文类型。对于2D图像而言，可以使用`CanvasRenderingContext2D`接口，获取方法：

```js
var canvas = document.getElementById('tutorial');
var ctx = canvas.getContext('2d');
```

## 绘制模板

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Canvas tutorial</title>
    <script type="text/javascript">
      function draw(){
        var canvas = document.getElementById('tutorial');
        if (canvas.getContext){
          var ctx = canvas.getContext('2d');
        }
      }
    </script>
    <style type="text/css">
      canvas { border: 1px solid black; }
    </style>
  </head>
  <body onload="draw();">
    <canvas id="tutorial" width="150" height="150"></canvas>
  </body>
</html>
```

## 用法

`canvas`支持绘制矩形和路径。

### 绘制矩形

```js
fillRect(x,y,width,height);//填充矩形
strokeRect(x,y,width,height);//矩形边框
clearRect(x,y,width,height);//清除矩形区域（透明）
```

这三个函数绘制后会立即生效，与后面的路径函数（Path function）有所区别。

### 绘制路径

步骤：

1. 创建路径起点
2. 使用画图命令
3. 关闭路径
4. 描边或填充路径

#### beginPath()

新建一条路径，将图形绘制命令指向该路径。在绘制路径的时候，会有一个路径列表记录子路径，即一个`beginPath()`下的所有路径。而当重新开始一个`beginPath()`时，会清空之前保存的记录，无论是否`stroke()`或者`fill()`。

[使用Canvas绘制图形](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes)

***

#### closePath()

闭合路径，将图形绘制命令重新指向上下文。不是必需的。

该命令会尝试连接当前点和起始点，使图形闭合，如果已经是闭合图形或只有一个点则不作操作。但是该命令不会重建一条新路径，它与`beginPath()`没有关系。

当调用`fill()`时，未闭合形状自动闭合，但是`stroke()`不会。

[_canvas里的beginPath和closePath_](https://blog.csdn.net/weixin_34124651/article/details/89009953?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-2.fixedcolumn&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-2.fixedcolumn)&emsp;[_理解beginPath和closePath_](https://blog.csdn.net/qq_33448537/article/details/61698180)

***

#### `stroke()`

通过线条绘制图形轮廓,将路径列表中的子路径全部绘出。

#### `fill()`

通过填充路径内容生成实心的图形。

#### `moveTo(x,y)`

移动画笔到指定的x和y坐标上，设置路径起点。

#### `lineTo(x,y)`

绘制直线，从当前位置到x和y坐标上。

### 绘制三角形

```js
  // 填充三角形
  ctx.beginPath();
  ctx.moveTo(25, 25);
  ctx.lineTo(105, 25);
  ctx.lineTo(25, 105);
  ctx.fill();

  // 描边三角形
  ctx.beginPath();
  ctx.moveTo(125, 125);
  ctx.lineTo(125, 45);
  ctx.lineTo(45, 125);
  ctx.closePath();
  ctx.stroke();
```

### 圆弧



***
[上一章：00.开始之前](./01.开始之前.md)  

[下一章：01.环境配置](./01.环境配置.md)  

[返回目录](./index.md)